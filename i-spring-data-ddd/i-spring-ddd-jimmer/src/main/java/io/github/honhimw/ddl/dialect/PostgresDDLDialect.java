package io.github.honhimw.ddl.dialect;

import io.github.honhimw.ddl.DatabaseVersion;
import org.babyfish.jimmer.sql.dialect.PostgresDialect;

import static java.sql.Types.*;

/**
 * @author honhimW
 * @since 2025-06-27
 */

public class PostgresDDLDialect extends DefaultDDLDialect {

    public PostgresDDLDialect() {
        this(null);
    }
    public PostgresDDLDialect(final DatabaseVersion version) {
        super(new PostgresDialect(), version);
    }

    @Override
    public String getIdentityColumnString(int type) {
        return "generated by default as identity";
    }

    @Override
    public String columnType(int jdbcType, Long length, Integer precision, Integer scale) {
        length = getLength(jdbcType, length);
        precision = getPrecision(jdbcType, precision);
        scale = getScale(jdbcType, scale);
        return switch (jdbcType) {
            case TINYINT ->
                // no tinyint, not even in Postgres 11
                "smallint";
            // there are no nchar/nvarchar types in Postgres
            case NCHAR -> columnType(CHAR, length, precision, scale);
            case NVARCHAR -> columnType(VARCHAR, length, precision, scale);
            case BLOB, CLOB, NCLOB ->
                // use oid as the blob/clob type on Postgres because
                // the JDBC driver doesn't allow using bytea/text via
                // LOB APIs
                "oid";
            case FLOAT -> "float4";
            case SQLXML -> "xml";
            // use bytea as the "long" binary type (that there is no
            // real VARBINARY type in Postgres, so we always use this)
            case BINARY, VARBINARY -> "bytea";

            default -> super.columnType(jdbcType, length, precision, scale);
        };
    }

    @Override
    public String getCascadeConstraintsString() {
        return "cascade";
    }
}
