package io.github.honhimw.ddl.dialect;

import io.github.honhimw.ddl.DDLUtils;
import io.github.honhimw.ddl.DatabaseVersion;
import org.babyfish.jimmer.sql.dialect.OracleDialect;

import static java.sql.Types.*;

/**
 * @author honhimW
 * @since 2025-06-27
 */

public class OracleDDLDialect extends DefaultDDLDialect {

    public OracleDDLDialect() {
        this(null);
    }

    public OracleDDLDialect(final DatabaseVersion version) {
        super(new OracleDialect(), version);
    }

    @Override
    public String columnType(int jdbcType, Long length, Integer precision, Integer scale) {
        length = getLength(jdbcType, length);
        precision = getPrecision(jdbcType, precision);
        scale = getScale(jdbcType, scale);
        return switch (jdbcType) {
            case BOOLEAN -> {
                if (isSameOrAfter(23)) {
                    yield super.columnType(jdbcType, length, precision, scale);
                } else {
                    yield "number(1,0)";
                }
            }
            case TINYINT -> "number(3,0)";
            case SMALLINT -> "number(5,0)";
            case INTEGER -> "number(10,0)";
            case BIGINT -> "number(19,0)";
            case REAL ->
                // Oracle's 'real' type is actually double precision
                "float(24)";
            case DOUBLE ->
                // Oracle's 'double precision' means float(126), and
                // we never need 126 bits (38 decimal digits)
                "float(53)";
            case NUMERIC, DECIMAL ->
                // Note that 38 is the maximum precision Oracle supports
                DDLUtils.replace("number($p,$s)", null, precision, scale);
            case DATE -> "date";
            case TIME -> DDLUtils.replace("timestamp($p)", null, precision, null);
            // the only difference between date and timestamp
            // on Oracle is that date has no fractional seconds
            case TIME_WITH_TIMEZONE -> DDLUtils.replace("timestamp($p) with time zone", null, precision, null);
            case VARCHAR -> DDLUtils.replace("varchar2($l char)", length, null, null);
            case NVARCHAR -> DDLUtils.replace("nvarchar2($l)", length, null, null);
            case BINARY, VARBINARY -> DDLUtils.replace("raw($l)", length, null, null);

            case SQLXML -> "SYS.XMLTYPE";

            default -> super.columnType(jdbcType, length, precision, scale);
        };
    }

    @Override
    public String getIdentityColumnString(int type) {
        return "generated by default as identity";
    }

    @Override
    public boolean supportsIfExistsBeforeTableName() {
        return isSameOrAfter(23);
    }

    @Override
    public String getCascadeConstraintsString() {
        return "cascade constraints";
    }

    @Override
    public boolean supportsIfExistsAfterAlterTable() {
        return isSameOrAfter(23);
    }

    @Override
    public boolean supportsIfExistsBeforeConstraintName() {
        return false;
    }

    @Override
    public boolean supportsIfExistsAfterDropSequence() {
        return isSameOrAfter(23);
    }
}
